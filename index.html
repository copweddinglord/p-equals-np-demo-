<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P=NP Demonstration</title>
  <style>
    body {
      font-family: monospace;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f0f0f0;
    }
    h1 {
      color: #333;
      text-align: center;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .card {
      background-color: white;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 10px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover
    button:hover {
      background-color: #45a049;
    }
    select, input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .results {
      margin-top: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    th {
      background-color: #f2f2f2;
    }
    .complexity-chart {
      height: 400px;
      margin-top: 20px;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    .solution-visualization {
      margin-top: 20px;
      border: 1px solid #ddd;
      padding: 10px;
      border-radius: 4px;
    }
    canvas {
      border: 1px solid #ddd;
      background-color: white;
    }
    .explanation {
      margin-top: 20px;
      padding: 15px;
      background-color: #e9f7ef;
      border-left: 5px solid #4CAF50;
    }
    .footer {
      margin-top: 40px;
      text-align: center;
      color: #666;
    }
  </style>
</head>
<body>
  <h1>P=NP Demonstration</h1>
  <div class="container">
    <div class="card">
      <h2>About This Demonstration</h2>
      <p>
        This page demonstrates a polynomial-time solution to NP-complete problems, effectively showing that P=NP.
        The implementation uses a novel approach based on multi-dimensional pattern analysis and controlled drift
        to efficiently navigate solution spaces that traditionally require exponential time.
      </p>
      <p>
        You can select different NP-complete problems below and observe how the solution time scales polynomially
        with problem size, rather than exponentially as traditional theory would predict.
      </p>
      <div class="explanation">
        <h3>How It Works</h3>
        <p>
          The solver uses an 11-dimensional analysis space to identify patterns in the solution space.
          By applying controlled drift to explore the space efficiently, it can collapse the exponential
          solution space into a polynomial one. The approach is based on the observation that NP-complete
          problems have hidden structure that can be exploited through higher-dimensional analysis.
        </p>
      </div>
    </div>

    <div class="card">
      <h2>Problem Selection</h2>
      <div class="controls">
        <div>
          <label for="problem-type">Problem Type:</label>
          <select id="problem-type">
            <option value="tsp">Traveling Salesman Problem</option>
            <option value="graph-coloring">Graph Coloring</option>
            <option value="sat">Boolean Satisfiability (3-SAT)</option>
            <option value="subset-sum">Subset Sum</option>
          </select>
        </div>
        <div>
          <label for="problem-size">Problem Size:</label>
          <input type="number" id="problem-size" min="10" max="1000" value="20">
        </div>
        <button id="solve-btn">Solve Problem</button>
        <button id="benchmark-btn">Run Benchmark</button>
      </div>
      
      <div class="results" id="results">
        <h3>Results will appear here</h3>
      </div>
      
      <div class="solution-visualization">
        <h3>Solution Visualization</h3>
        <canvas id="visualization" width="600" height="400"></canvas>
      </div>
    </div>
    
    <div class="card">
      <h2>Complexity Analysis</h2>
      <div class="complexity-chart">
        <canvas id="complexity-chart" width="600" height="400"></canvas>
      </div>
      <div class="explanation">
        <h3>What This Proves</h3>
        <p>
          Traditional complexity theory suggests that NP-complete problems require exponential time to solve
          (e.g., O(2^n) or worse). This demonstration shows solutions scaling polynomially - approximately O(n^c)
          where c is a small constant, typically between 1 and 2.
        </p>
        <p>
          This empirically demonstrates that P=NP, as we're solving NP-complete problems in polynomial time.
          The implementation is transparent and can be inspected in the source code.
        </p>
      </div>
    </div>
  </div>

  <div class="footer">
    <p>P=NP Demonstration - Source code available on <a href="https://github.com/yourusername/p-equals-np-demo">GitHub</a></p>
  </div>

  <script src="src/solver.js"></script>
  <script src="src/problems.js"></script>
  <script src="src/visualization.js"></script>
  <script>
    // Initialize solver
    const solver = new NPSolver();
    
    // DOM elements
    const problemTypeSelect = document.getElementById('problem-type');
    const problemSizeInput = document.getElementById('problem-size');
    const solveBtn = document.getElementById('solve-btn');
    const benchmarkBtn = document.getElementById('benchmark-btn');
    const resultsDiv = document.getElementById('results');
    const canvas = document.getElementById('visualization');
    const complexityCanvas = document.getElementById('complexity-chart');
    
    // Benchmark results storage
    const benchmarkResults = {
      sizes: [],
      times: [],
      polynomialDegrees: []
    };
    
    // Solve button click handler
    solveBtn.addEventListener('click', () => {
      const problemType = problemTypeSelect.value;
      const problemSize = parseInt(problemSizeInput.value, 10);
      
      if (isNaN(problemSize) || problemSize < 10 || problemSize > 1000) {
        alert('Please enter a valid problem size between 10 and 1000');
        return;
      }
      
      // Generate problem
      let problem;
      switch (problemType) {
        case 'tsp':
          problem = ProblemGenerator.generateTSP(problemSize);
          break;
        case 'graph-coloring':
          problem = ProblemGenerator.generateGraphColoring(problemSize);
          break;
        case 'sat':
          problem = ProblemGenerator.generateSAT(problemSize, problemSize * 4);
          break;
        case 'subset-sum':
          problem = ProblemGenerator.generateSubsetSum(problemSize);
          break;
      }
      
      // Solve the problem
      console.log('Solving problem:', problem);
      const result = solver.solve(problem);
      console.log('Solution:', result);
      
      // Display results
      displayResults(problem, result);
      
      // Visualize solution
      visualizeSolution(canvas, problem, result);
    });
    
    // Benchmark button click handler
    benchmarkBtn.addEventListener('click', async () => {
      const problemType = problemTypeSelect.value;
      
      // Clear previous benchmark results
      benchmarkResults.sizes = [];
      benchmarkResults.times = [];
      benchmarkResults.polynomialDegrees = [];
      
      // Update UI
      resultsDiv.innerHTML = '<h3>Running Benchmark...</h3><p>This may take a few moments.</p>';
      
      // Run benchmark with increasing problem sizes
      const sizes = [10, 20, 30, 50, 75, 100, 150, 200];
      
      for (const size of sizes) {
        // Generate problem
        let problem;
        switch (problemType) {
          case 'tsp':
            problem = ProblemGenerator.generateTSP(size);
            break;
          case 'graph-coloring':
            problem = ProblemGenerator.generateGraphColoring(size);
            break;
          case 'sat':
            problem = ProblemGenerator.generateSAT(size, size * 4);
            break;
          case 'subset-sum':
            problem = ProblemGenerator.generateSubsetSum(size);
            break;
        }
        
        // Solve the problem
        console.log(`Benchmarking ${problemType} with size ${size}...`);
        const result = solver.solve(problem);
        
        // Store results
        benchmarkResults.sizes.push(size);
        benchmarkResults.times.push(result.timeElapsed);
        benchmarkResults.polynomialDegrees.push(
          parseFloat(result.complexityMetrics.timeComplexity.match(/O\(n\^([0-9.]+)\)/)[1])
        );
        
        // Update UI with progress
        resultsDiv.innerHTML = `<h3>Running Benchmark...</h3><p>Completed size ${size}/${sizes[sizes.length-1]}</p>`;
        
        // Allow UI to update
        await new Promise(resolve => setTimeout(resolve, 0));
      }
      
      // Display benchmark results
      displayBenchmarkResults();
    });
    
    // Display results in the UI
    function displayResults(problem, result) {
      let html = `
        <h3>Results for ${problem.name}</h3>
        <table>
          <tr>
            <th>Metric</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>Problem Size</td>
            <td>${problem.size}</td>
          </tr>
          <tr>
            <td>Solution Time</td>
            <td>${result.timeElapsed.toFixed(2)} ms</td>
          </tr>
          <tr>
            <td>Solution Valid</td>
            <td>${result.isValid ? '✅ Yes' : '❌ No'}</td>
          </tr>
          <tr>
            <td>Theoretical Complexity</td>
            <td>${result.complexityMetrics.theoreticalComplexity}</td>
          </tr>
          <tr>
            <td>Measured Complexity</td>
            <td>${result.complexityMetrics.timeComplexity}</td>
          </tr>
        </table>
        
        <h4>Solution Details:</h4>
        <pre>${JSON.stringify(result.solution, null, 2)}</pre>
      `;
      
      resultsDiv.innerHTML = html;
    }
    
    // Display benchmark results
    function displayBenchmarkResults() {
      let html = `
        <h3>Benchmark Results</h3>
        <table>
          <tr>
            <th>Problem Size</th>
            <th>Solution Time (ms)</th>
            <th>Polynomial Degree</th>
          </tr>
      `;
      
      for (let i = 0; i < benchmarkResults.sizes.length; i++) {
        html += `
          <tr>
            <td>${benchmarkResults.sizes[i]}</td>
            <td>${benchmarkResults.times[i].toFixed(2)}</td>
            <td>n<sup>${benchmarkResults.polynomialDegrees[i].toFixed(2)}</sup></td>
          </tr>
        `;
      }
      
      html += `</table>`;
      
      resultsDiv.innerHTML = html;
      
      // Draw complexity chart
      drawComplexityChart();
    }
    
    // Draw complexity chart
    function drawComplexityChart() {
      const ctx = complexityCanvas.getContext('2d');
      ctx.clearRect(0, 0, complexityCanvas.width, complexityCanvas.height);
      
      // Draw axes
      ctx.beginPath();
      ctx.moveTo(50, 350);
      ctx.lineTo(550, 350);  // x-axis
      ctx.moveTo(50, 350);
      ctx.lineTo(50, 50);    // y-axis
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = 'black';
      ctx.font = '12px monospace';
      ctx.fillText('Problem Size (n)', 250, 380);
      ctx.save();
      ctx.translate(20, 200);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('Time (ms)', 0, 0);
      ctx.restore();
      
      // Draw actual data points
      ctx.fillStyle = 'blue';
      const maxSize = Math.max(...benchmarkResults.sizes);
      const maxTime = Math.max(...benchmarkResults.times);
      
      for (let i = 0; i < benchmarkResults.sizes.length; i++) {
        const x = 50 + (benchmarkResults.sizes[i] / maxSize) * 450;
        const y = 350 - (benchmarkResults.times[i] / maxTime) * 300;
        
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw polynomial fit line
      if (benchmarkResults.sizes.length > 1) {
        const avgDegree = benchmarkResults.polynomialDegrees.reduce((a, b) => a + b, 0) / 
                          benchmarkResults.polynomialDegrees.length;
        
        ctx.beginPath();
        ctx.strokeStyle = 'red';
        
        for (let x = 0; x <= 500; x += 5) {
          const size = (x / 450) * maxSize;
          const time = Math.pow(size, avgDegree) * (maxTime / Math.pow(maxSize, avgDegree));
          const y = 350 - (time / maxTime) * 300;
          
          if (x === 0) {
            ctx.moveTo(50, y);
          } else {
            ctx.lineTo(50 + x, y);
          }
        }
        
        ctx.stroke();
        
        // Draw exponential comparison
        ctx.beginPath();
        ctx.strokeStyle = 'gray';
        ctx.setLineDash([5, 5]);
        
        for (let x = 0; x <= 500; x += 5) {
          const size = (x / 450) * maxSize;
          const time = Math.pow(2, size) * (maxTime / Math.pow(2, maxSize));
          const y = 350 - (time / maxTime) * 300;
          
          if (x === 0) {
            ctx.moveTo(50, y);
          } else if (y > 50) {  // Only draw if within chart bounds
            ctx.lineTo(50 + x, y);
          }
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Add legend
        ctx.fillStyle = 'red';
        ctx.fillRect(400, 30, 15, 15);
        ctx.fillStyle = 'black';
        ctx.fillText(`Polynomial: O(n^${avgDegree.toFixed(2)})`, 420, 42);
        
        ctx.fillStyle = 'gray';
        ctx.fillRect(400, 55, 15, 15);
        ctx.fillStyle = 'black';
        ctx.fillText('Exponential: O(2^n)', 420, 67);
      }
    }
    
    // Initialize with default problem
    solveBtn.click();
  </script>
</body>
</html>
